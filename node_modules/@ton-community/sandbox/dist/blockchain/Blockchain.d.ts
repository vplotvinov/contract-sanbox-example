import { Address, Cell, Message, Transaction, ContractProvider, Contract, Sender, ShardAccount, TupleItem } from "ton-core";
import { Executor } from "../executor/Executor";
import { BlockchainStorage } from "./BlockchainStorage";
import { Event } from "../event/Event";
import { TreasuryContract } from "../treasury/Treasury";
import { LogsVerbosity, SmartContract, Verbosity } from "./SmartContract";
export type SendMessageResult = {
    transactions: Transaction[];
    events: Event[];
};
export type OpenedContract<F> = {
    [P in keyof F]: P extends `get${string}` ? (F[P] extends (x: ContractProvider, ...args: infer P) => infer R ? (...args: P) => R : never) : (P extends `send${string}` ? (F[P] extends (x: ContractProvider, ...args: infer P) => infer R ? (...args: P) => Promise<SendMessageResult & {
        result: R extends Promise<infer PR> ? PR : R;
    }> : never) : F[P]);
};
export declare class Blockchain {
    #private;
    storage: BlockchainStorage;
    private networkConfig;
    readonly executor: Executor;
    readonly messageQueue: Message[];
    get lt(): bigint;
    private constructor();
    get config(): Cell;
    sendMessage(message: Message | Cell): Promise<SendMessageResult>;
    runGetMethod(address: Address, method: number | string, stack?: TupleItem[]): Promise<{
        stack: TupleItem[];
        stackReader: import("ton-core").TupleReader;
        exitCode: number;
        gasUsed: string;
        logs: string;
    }>;
    private pushMessage;
    private runQueue;
    private processQueue;
    provider(address: Address, init?: {
        code: Cell;
        data: Cell;
    }): ContractProvider;
    sender(address: Address): Sender;
    treasury(seed: string, workchain?: number): Promise<OpenedContract<TreasuryContract>>;
    openContract<T extends Contract>(contract: T): OpenedContract<T>;
    private startFetchingContract;
    getContract(address: Address): Promise<SmartContract>;
    get verbosity(): LogsVerbosity;
    set verbosity(value: LogsVerbosity);
    setVerbosityForAddress(address: Address, verbosity: Partial<LogsVerbosity> | Verbosity | undefined): Promise<void>;
    setConfig(config: Cell): void;
    setShardAccount(address: Address, account: ShardAccount): Promise<void>;
    static create(opts?: {
        config?: Cell;
        storage?: BlockchainStorage;
    }): Promise<Blockchain>;
}
