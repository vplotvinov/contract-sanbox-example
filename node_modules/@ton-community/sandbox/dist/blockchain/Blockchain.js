"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Blockchain_lt, _Blockchain_verbosity, _Blockchain_lock, _Blockchain_contractFetches;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blockchain = void 0;
const defaultConfig_1 = require("../config/defaultConfig");
const ton_core_1 = require("ton-core");
const Executor_1 = require("../executor/Executor");
const BlockchainStorage_1 = require("./BlockchainStorage");
const Event_1 = require("../event/Event");
const BlockchainContractProvider_1 = require("./BlockchainContractProvider");
const BlockchainSender_1 = require("./BlockchainSender");
const testKey_1 = require("../utils/testKey");
const Treasury_1 = require("../treasury/Treasury");
const AsyncLock_1 = require("../utils/AsyncLock");
const message_1 = require("../utils/message");
const LT_ALIGN = 1000000n;
class Blockchain {
    get lt() {
        return __classPrivateFieldGet(this, _Blockchain_lt, "f");
    }
    constructor(opts) {
        _Blockchain_lt.set(this, 0n);
        this.messageQueue = [];
        _Blockchain_verbosity.set(this, {
            blockchainLogs: false,
            vmLogs: 'none',
            debugLogs: true,
        });
        _Blockchain_lock.set(this, new AsyncLock_1.AsyncLock());
        _Blockchain_contractFetches.set(this, new Map());
        this.networkConfig = opts.config ?? ton_core_1.Cell.fromBoc(Buffer.from(defaultConfig_1.defaultConfig, 'base64'))[0];
        this.executor = opts?.executor;
        this.storage = opts.storage;
    }
    get config() {
        return this.networkConfig;
    }
    async sendMessage(message) {
        await this.pushMessage(message);
        return await this.runQueue();
    }
    async runGetMethod(address, method, stack = []) {
        return (await this.getContract(address)).get(method, stack);
    }
    async pushMessage(message) {
        const msg = message instanceof ton_core_1.Cell ? (0, ton_core_1.loadMessage)(message.beginParse()) : message;
        if (msg.info.type === 'external-out') {
            throw new Error('Cannot send external out message');
        }
        await __classPrivateFieldGet(this, _Blockchain_lock, "f").with(async () => {
            this.messageQueue.push(msg);
        });
    }
    async runQueue() {
        const txes = await this.processQueue();
        return {
            transactions: txes,
            events: txes.map(tx => (0, Event_1.extractEvents)(tx)).flat(),
        };
    }
    async processQueue() {
        return await __classPrivateFieldGet(this, _Blockchain_lock, "f").with(async () => {
            let result = [];
            while (this.messageQueue.length > 0) {
                let message = this.messageQueue.shift();
                if (message.info.type === 'external-out') {
                    continue;
                }
                __classPrivateFieldSet(this, _Blockchain_lt, __classPrivateFieldGet(this, _Blockchain_lt, "f") + LT_ALIGN, "f");
                let transaction = await (await this.getContract(message.info.dest)).receiveMessage(message);
                result.push(transaction);
                for (let message of transaction.outMessages.values()) {
                    this.messageQueue.push(message);
                    if (message.info.type === 'internal') {
                        this.startFetchingContract(message.info.dest);
                    }
                }
            }
            return result;
        });
    }
    provider(address, init) {
        return new BlockchainContractProvider_1.BlockchainContractProvider({
            getContract: (addr) => this.getContract(addr),
            pushMessage: (msg) => this.pushMessage(msg),
        }, address, init);
    }
    sender(address) {
        return new BlockchainSender_1.BlockchainSender({
            pushMessage: (msg) => this.pushMessage(msg),
        }, address);
    }
    async treasury(seed, workchain = 0) {
        const key = (0, testKey_1.testKey)(seed);
        const treasury = Treasury_1.TreasuryContract.create(workchain, key);
        const wallet = this.openContract(treasury);
        const contract = await this.getContract(treasury.address);
        if (contract.accountState === undefined || contract.accountState.type === 'uninit') {
            await this.sendMessage((0, message_1.internal)({
                from: new ton_core_1.Address(0, Buffer.alloc(32)),
                to: wallet.address,
                value: (0, ton_core_1.toNano)(1),
                stateInit: wallet.init,
            }));
            contract.balance = (0, ton_core_1.toNano)(1000000);
        }
        else if (contract.balance === 0n) {
            contract.balance = (0, ton_core_1.toNano)(1000000);
        }
        return wallet;
    }
    openContract(contract) {
        let address;
        let init = undefined;
        if (!ton_core_1.Address.isAddress(contract.address)) {
            throw Error('Invalid address');
        }
        address = contract.address;
        if (contract.init) {
            if (!(contract.init.code instanceof ton_core_1.Cell)) {
                throw Error('Invalid init.code');
            }
            if (!(contract.init.data instanceof ton_core_1.Cell)) {
                throw Error('Invalid init.data');
            }
            init = contract.init;
        }
        const provider = this.provider(address, init);
        const blkch = this;
        return new Proxy(contract, {
            get(target, prop) {
                const value = target[prop];
                if (typeof prop === 'string' && typeof value === 'function') {
                    if (prop.startsWith('get')) {
                        return (...args) => value.apply(target, [provider, ...args]);
                    }
                    else if (prop.startsWith('send')) {
                        return async (...args) => {
                            const ret = value.apply(target, [provider, ...args]);
                            if (ret instanceof Promise) {
                                const r = await ret;
                                return {
                                    ...await blkch.runQueue(),
                                    result: r,
                                };
                            }
                            else {
                                return {
                                    ...await blkch.runQueue(),
                                    result: ret,
                                };
                            }
                        };
                    }
                }
                return value;
            }
        });
    }
    startFetchingContract(address) {
        const addrString = address.toRawString();
        let promise = __classPrivateFieldGet(this, _Blockchain_contractFetches, "f").get(addrString);
        if (promise !== undefined) {
            return promise;
        }
        promise = this.storage.getContract(this, address);
        __classPrivateFieldGet(this, _Blockchain_contractFetches, "f").set(addrString, promise);
        return promise;
    }
    async getContract(address) {
        const contract = await this.startFetchingContract(address);
        __classPrivateFieldGet(this, _Blockchain_contractFetches, "f").delete(address.toRawString());
        return contract;
    }
    get verbosity() {
        return __classPrivateFieldGet(this, _Blockchain_verbosity, "f");
    }
    set verbosity(value) {
        __classPrivateFieldSet(this, _Blockchain_verbosity, value, "f");
    }
    async setVerbosityForAddress(address, verbosity) {
        const contract = await this.getContract(address);
        contract.setVerbosity(verbosity);
    }
    setConfig(config) {
        this.networkConfig = config;
    }
    async setShardAccount(address, account) {
        const contract = await this.getContract(address);
        contract.account = account;
    }
    static async create(opts) {
        return new Blockchain({
            executor: await Executor_1.Executor.create(),
            storage: opts?.storage ?? new BlockchainStorage_1.LocalBlockchainStorage(),
            ...opts
        });
    }
}
exports.Blockchain = Blockchain;
_Blockchain_lt = new WeakMap(), _Blockchain_verbosity = new WeakMap(), _Blockchain_lock = new WeakMap(), _Blockchain_contractFetches = new WeakMap();
