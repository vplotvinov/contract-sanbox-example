/// <reference types="node" />
import { AxiosAdapter } from "axios";
import { Address, Cell, Contract, ContractProvider, Transaction, TupleItem } from "ton-core";
export declare type TonClient4Parameters = {
    /**
     * API endpoint
     */
    endpoint: string;
    /**
     * HTTP request timeout in milliseconds.
     */
    timeout?: number;
    /**
     * HTTP Adapter for axios
     */
    httpAdapter?: AxiosAdapter;
};
export declare class TonClient4 {
    #private;
    constructor(args: TonClient4Parameters);
    /**
     * Get Last Block
     * @returns last block info
     */
    getLastBlock(): Promise<{
        last: {
            seqno: number;
            shard: string;
            workchain: number;
            fileHash: string;
            rootHash: string;
        };
        init: {
            fileHash: string;
            rootHash: string;
        };
        stateRootHash: string;
        now: number;
    }>;
    /**
     * Get block info
     * @param seqno block sequence number
     * @returns block info
     */
    getBlock(seqno: number): Promise<{
        shards: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
            transactions: {
                account: string;
                hash: string;
                lt: string;
            }[];
        }[];
    }>;
    /**
     * Get block info by unix timestamp
     * @param ts unix timestamp
     * @returns block info
     */
    getBlockByUtime(ts: number): Promise<{
        shards: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
            transactions: {
                account: string;
                hash: string;
                lt: string;
            }[];
        }[];
    }>;
    /**
     * Get block info by unix timestamp
     * @param seqno block sequence number
     * @param address account address
     * @returns account info
     */
    getAccount(seqno: number, address: Address): Promise<{
        account: {
            state: {
                type: "uninit";
            } | {
                type: "active";
                code: string | null;
                data: string | null;
            } | {
                type: "frozen";
                stateHash: string;
            };
            balance: {
                coins: string;
            };
            last: {
                lt: string;
                hash: string;
            } | null;
            storageStat: {
                lastPaid: number;
                duePayment: string | null;
                used: {
                    bits: number;
                    cells: number;
                    publicCells: number;
                };
            } | null;
        };
        block: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
    }>;
    /**
     * Get account lite info (without code and data)
     * @param seqno block sequence number
     * @param address account address
     * @returns account lite info
     */
    getAccountLite(seqno: number, address: Address): Promise<{
        account: {
            state: {
                type: "uninit";
            } | {
                type: "active";
                codeHash: string;
                dataHash: string;
            } | {
                type: "frozen";
                stateHash: string;
            };
            balance: {
                coins: string;
            };
            last: {
                lt: string;
                hash: string;
            } | null;
            storageStat: {
                lastPaid: number;
                duePayment: string | null;
                used: {
                    bits: number;
                    cells: number;
                    publicCells: number;
                };
            } | null;
        };
    }>;
    /**
     * Check if account was updated since
     * @param seqno block sequence number
     * @param address account address
     * @param lt account last transaction lt
     * @returns account change info
     */
    isAccountChanged(seqno: number, address: Address, lt: bigint): Promise<{
        changed: boolean;
        block: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
    }>;
    /**
     * Load one unparsed account transaction
     * @param seqno block sequence number
     * @param address account address
     * @param lt account last transaction lt
     * @returns one unparsed transaction
     */
    getTransaction(seqno: number, address: Address, lt: bigint): Promise<{
        block: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
        };
        boc: string;
        proof: string;
        tx: {
            address: bigint;
            lt: bigint;
            prevTransactionHash: bigint;
            prevTransactionLt: bigint;
            now: number;
            outMessagesCount: number;
            oldStatus: import("ton-core").AccountStatus;
            endStatus: import("ton-core").AccountStatus;
            inMessage: import("ton-core").Message | undefined;
            outMessages: import("ton-core").Dictionary<number, import("ton-core").Message>;
            totalFees: import("ton-core").CurrencyCollection;
            stateUpdate: import("ton-core").HashUpdate;
            description: import("ton-core").TransactionDescription;
        };
    }>;
    /**
     * Load unparsed account transactions
     * @param address address
     * @param lt last transaction lt
     * @param hash last transaction hash
     * @returns unparsed transactions
     */
    getAccountTransactions(address: Address, lt: bigint, hash: Buffer): Promise<{
        block: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
        tx: Transaction;
    }[]>;
    /**
     * Get network config
     * @param seqno block sequence number
     * @param ids optional config ids
     * @returns network config
     */
    getConfig(seqno: number, ids?: number[]): Promise<{
        config: {
            cell: string;
            address: string;
            globalBalance: {
                coins: string;
            };
        };
    }>;
    /**
     * Execute run method
     * @param seqno block sequence number
     * @param address account address
     * @param name method name
     * @param args method arguments
     * @returns method result
     */
    runMethod(seqno: number, address: Address, name: string, args?: TupleItem[]): Promise<{
        exitCode: number;
        result: TupleItem[];
        resultRaw: string | null;
        block: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
        shardBlock: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
    }>;
    /**
     * Send external message
     * @param message message boc
     * @returns message status
     */
    sendMessage(message: Buffer): Promise<{
        status: number;
    }>;
    /**
     * Open smart contract
     * @param contract contract
     * @returns opened contract
     */
    open<T extends Contract>(contract: T): { [P in keyof T]: P extends `get${string}` | `send${string}` ? T[P] extends (x: ContractProvider, ...args: infer P_1) => infer R ? (...args: P_1) => R : never : T[P]; };
    /**
     * Open smart contract
     * @param block block number
     * @param contract contract
     * @returns opened contract
     */
    openAt<T extends Contract>(block: number, contract: T): { [P in keyof T]: P extends `get${string}` | `send${string}` ? T[P] extends (x: ContractProvider, ...args: infer P_1) => infer R ? (...args: P_1) => R : never : T[P]; };
    /**
     * Create provider
     * @param address address
     * @param init optional init data
     * @returns provider
     */
    provider(address: Address, init?: {
        code: Cell;
        data: Cell;
    } | null): ContractProvider;
    /**
     * Create provider at specified block number
     * @param block block number
     * @param address address
     * @param init optional init data
     * @returns provider
     */
    providerAt(block: number, address: Address, init?: {
        code: Cell;
        data: Cell;
    } | null): ContractProvider;
}
